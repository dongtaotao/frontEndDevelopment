
HTTP
http://interview.poetries.top/excellent-docs/14-HTTP%E6%A8%A1%E5%9D%97.html#_6-4-http%E4%B8%8Ehttps%E5%8C%BA%E5%88%AB

TCP 和 UDP 的区别
TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接
TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失， 不重复，且按序到达;UDP 尽最大努力交付，
  即不保证可靠交付。 并且因为 tcp 可靠， 面向连接，不会丢失数据因此适合大数据量的交换
TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低(因此会出现丢包，对实时的应用比如 IP 电话和视频会议等)
TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多
TCP 的首部较大为 20 字节，而 UDP 只有 8 字节
TCP 是面向连接的可靠性传输，而 UDP 是不可靠的

相对于HTTP1.0，HTTP1.1的优化
1缓存处理：多了Entity tag，If-Unmodified-Since, If-Match, If-None-Match等缓存信息（HTTTP1.0 If-Modified-Since,Expires）
2带宽优化及网络连接的使用
3错误通知的管理
4Host头处理
5长连接： HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点

相对于HTTP1.1，HTTP2的优化

HTTP2支持二进制传送（实现方便且健壮），HTTP1.x是字符串传送
HTTP2支持多路复用 所有的相同域名请求都通过同一个TCP连接并发完成
HTTP2采用HPACK压缩算法压缩头部，减小了传输的体积
HTTP2支持服务端推送 ，意味着服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置再发起请求

6.2 https 协议的优点
使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器
HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性
HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本
#6.3 https 协议的缺点
https握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20% 的耗电
https 缓存不如 http 高效，会增加数据开销
SSL 证书也需要钱，功能越强大的证书费用越高
SSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗

https == http + 加密 + 身份验证 + 数据完整性保护

TLS 中的加密
对称加密 —— 两边拥有相同的秘钥，两边都知道如何将密文加密解密。
非对称加密 —— 有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道

6.6 HTTPS的整体过程分为证书验证和数据传输阶段

6.8 为什么https数据传输使用对称加密
对称加密： 对称加密指的就是加密和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥。
非对称加密: 加密和解密使用不同的秘钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。
通过上面的握手过程可知，https在证书验证阶段，使用非对称加密来传输共享秘钥，之后的传输中都使用对称加密方式。
原因是，非对称加密的加解密效率是非常低的，而http场景中通常端与端之间的交互量很大，对非对称加密的效率是无法忍受的。
另外， HTTPS场景中只有服务端保存了私钥，一对公私钥只能实现单向加解密过程。因此 HTTPS 中的内容传输采用对称加密

混合加密机制的好处是什么

对称密钥加密和非对称密钥加密都有它们各种的优缺点，而混合加密机制就是将两者结合利用它们各自的优点来进行加密传输。
比如既然对称密钥的优点是加解密效率快，那么在客户端与服务端确定了连接之后就可以用它来进行加密传输。不过前提是得解决双方都能安全
的拿到这把对称密钥。这时候就可以里用非对称密钥加密来传输这把对称密钥，因为我们知道非对称密钥加密的优点就是能保证传输的内容是安全的。
所以它的好处是即保证了对称密钥能在双方之间安全的传输，又能使用对称加密方式进行通信，这比单纯的使用非对称加密通信快了很多。以此来解
决了HTTP中内容可能被窃听的问题。

混合加密的缺点
混合加密主要是为了解决HTTP中内容可能被窃听的问题。但是它并不能保证数据的完整性，也就是说在传输的时候数据是有可能被第三方篡改的，
比如完全替换掉，所以说它并不能校验数据的完整性。如果需要做到这一点就需要使用到数字签名。

6.11 问题
1. 为什么数据传输是用对称加密
HTTP的应用场景中通常端与端之间存在大量的交互，非对称加密的加解密效率非常低。另外，在 HTTPS的场景中只有服务端保存了私钥，一对公私钥只能
实现单向的加解密，所以 HTTPS 中内容传输加密采取的是对称加密

2. 为什么需要证书?
防止“中间人”攻击，同时可以为网站提供身份证明。 

3. 使用 HTTPS 会被抓包吗?
会被抓包，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。

6.19 介绍下 HTTPS 中间人攻击
中间人攻击过程如下：

服务器向客户端发送公钥。
攻击者截获公钥，保留在自己手上。
然后攻击者自己生成一个【伪造的】公钥，发给客户端。
客户端收到伪造的公钥后，生成加密hash值发给服务器。
攻击者获得加密hash值，用自己的私钥解密获得真秘钥。
同时生成假的加密hash值，发给服务器。
服务器用私钥解密获得假秘钥。
服务器用加秘钥加密传输信息
防范方法：
服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性

6.20 http/https 协议总结
1.0 协议缺陷:

无法复用链接，完成即断开，重新慢启动和 TCP 3次握手
head of line blocking: 线头阻塞，导致请求之间互相影响
1.1 改进:

长连接(默认 keep-alive)，复用
host 字段指定对应的虚拟站点
新增功能:
断点续传
身份认证
状态管理
cache 缓存
Cache-Control
Expires
Last-Modified
Etag
2.0:

多路复用
二进制分帧层: 应用层和传输层之间
首部压缩
服务端推送
https: 较为安全的网络传输协议

证书(公钥)
SSL 加密
端口 443
TCP:

三次握手
四次挥手
滑动窗口: 流量控制
拥塞处理
慢开始
拥塞避免
快速重传
快速恢复
缓存策略: 可分为 强缓存 和 协商缓存

Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，Cache-Control的 max-age 优先级高于 Expires
当缓存已经过期时，使用协商缓存
唯一标识方案: Etag(response 携带) & If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改
最后一次修改时间: Last-Modified(response) & If-Modified-Since(request，上一次返回的Last-Modified)
如果一致，则直接返回 304 通知浏览器使用缓存
如不一致，则服务端返回新的资源

Last-Modified 缺点：
周期性修改，但内容未变时，会导致缓存失效
最小粒度只到 s， s 以内的改动无法检测到
Etag 的优先级高于Last-Modified

8.1 Cookie 和 session 的区别
HTTP 是一个无状态协议，因此 Cookie 的最大的作用就是存储 sessionId 用来唯一标识用户。

cookie 数据存放在客户的浏览器上，session 数据放在服务器上
cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗 考虑到安全应当使用 session
session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用 COOKIE
单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie

TCP 传输控制协议 面向连接 可靠传输，使用流量控制和拥塞控制 只能是一对一通信 面向字节流
  首部最小20字节，最大60字节 适用于要求可靠传输的应用，例如文件传输
UDP 用户数据报协议 无连接 不可靠传输，不使用流量控制和拥塞控制 支持一对一，一对多，多对一和多对多交互通信
  面向报文 首部开销小，仅8字节  适用于实时应用（IP电话、视频会议、直播等）

//================================================================
  Http和Https区别（高频）
  1.`HTTP` 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
  2.`HTTP` 是不安全的，而 HTTPS 是安全的
  3.`HTTP` 标准端口是80 ，而 HTTPS 的标准端口是443
  4.`在OSI` 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层
  5.`HTTP` 无法加密，而HTTPS 对传输的数据进行加密
  6.`HTTP`无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书

//================================================================
  1.GET在浏览器回退不会再次请求，POST会再次提交请求
  2.GET请求会被浏览器主动缓存，POST不会，要手动设置
  3.GET请求参数会被完整保留在浏览器历史记录里，POST中的参数不会
  4.GET请求在URL中传送的参数是有长度限制的，而POST没有限制
  5.GET参数通过URL传递，POST放在Request body中
  6.GET参数暴露在地址栏不安全，POST放在报文内部更安全
  7.GET一般用于查询信息，POST一般用于提交某种信息进行某些修改操作
  8.GET产生一个TCP数据包；POST产生两个TCP数据包

//================================================================
  XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时
  就会执行这些恶意代码，这些脚本可以读取 cookie，session tokens，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。
  CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站
  发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

  XSS避免方式：
  url参数使用encodeURIComponent方法转义
  尽量不使用InnerHtml插入HTML内容
  使用特殊符号、标签转义符。

  CSRF避免方式：
  添加验证码
  使用token

  服务端给用户生成一个token，加密后传递给用户
  用户在提交请求时，需要携带这个token
  服务端验证token是否正确

  //================================================================
  WebSocket
  由于 http存在一个明显的弊端，即消息只能由客户端推送到服务器端，而服务器端不能主动推送到客户端，导致如果服务器如果有连续的变化，这时只能使用轮询。而轮询效率过
  低，并不适合，于是 WebSocket被发明出来，相比与 http 具有以下优点 
  支持双向通信，实时性更强；
  可以发送文本，也可以二进制文件；
  协议标识符是 ws，加密后是 wss ；
  较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。
  支持扩展。
  无跨域问题。
  实现比较简单，服务端库如 socket.io、ws，可以很好的帮助入门。客户端也只需要参照 api 实现即可

//===============================================================
JSBridge通信原理
Native调用JS
webview 作为 H5 的宿主，Native 可以通过 webview 的 API直接执行 Js 代码，例如：
ios可以通过webview的evaluateJavaScript:completionHandler方法来运行js的代码
android可以通过webview的loadUrl()去调用js代码，也可以使用evaluateJavascript()来调用js代码
JS调用Native，有3种常见的方案：
1.WebView URL Scheme 跳转拦截
  URL SCHEME 是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的。
  拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME
  （包括所带的参数）进行相关操作。
2.WebView中的prompt/console/alert拦截
  ，因为这个方法在前端中使用频率低，比较不会出现冲突
3.WebView API注入
  通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的
  Native 代码逻辑，达到 JavaScript 调用 Native 的目的
链接：https://www.jianshu.com/p/4bdd0294ae46