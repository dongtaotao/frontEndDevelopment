//============================================================================
web worker可以用在什么场景中
在worker线程中你可以运行任何你喜欢的代码，不过有一些例外情况。比如：在worker内，不能直接操作DOM节点，
也不能使用window对象的默认方法和属性。
Web Worker 是脱离在主线程之外的，将一些复杂的耗时的活交给它干完成后通过 postMessage 方法告诉
主线程。Web worker是一个独立的运行环境，不能操作DOM和BOM。
window.postMessage这个方法可以实现跨域：就是将该窗口的访问数据传递到另一个窗口。
两个窗口中localstorage存储的数据不能相互访问。
链接：https://juejin.cn/post/7026701472322551815

//================================================================
单例模式
class Person {
  constructor(name) {
    this.name = name;
    this.p = null
  }
  static instance(name) {
    if (!this.p) {
      this.p = new Person(name)
    }
    return this.p
  }
}
//=================================================================
7.聊聊 redux-thunk 是如何实现异步 action 的？
在 redux-thunk 中会判断 action 的类型，
如果 action 的类型为函数，则执行 该 action 函数，并且将 dispatch 作为参数，将自身的
dispatch 操作延迟 到 action 函数中执行，由 action 函数决定何时（可能是异步操作后）执 行
dispatch.

//================================================================
9.介绍下 webpack 热更新原理，是如何做到 在不刷新浏览器的前提下更新页面的
1).当修改了一个或多个文件；
2).文件系统接收更改并通知 webpack；
3).webpack 重新编译构建一个或多个模块，并通知HMR （ Hot Module Replacement）
服务器进行更新；
4).HMR Server 使用 Websocket 通知 HMR runtime 需要更新，HMR runtime 通过 HTTP 请求更新
jsonp；
5).HMR runtime 替换更新中的模块，如果确定这些模块无法更新，则触发整 个页面刷新；

//================================================================
git fetch和git pull的区别
git pull：相当于是从远程获取最新版本并merge到本地
git fetch：相当于是从远程获取最新版本到本地，不会自动merge

//================================================================
伪类和伪元素的区别
伪类表状态
伪元素是真的有元素
前者单冒号，后者双冒号

//=================================================================
base64的使用
用于减少 HTTP 请求
适用于小图片
base64的体积约为原图的4/3

硬件加速是指通过创建独立的复合图层，让GPU来渲染这个图层，从而提高性能，
一般触发硬件加速的CSS属性有transform、opacity、filter，为了避免2D动画在
开始和结束的时候的repaint操作，一般使用tranform:translateZ(0)

//================================================================
如何实现小于12px的字体效果
transform:scale()这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，
我们可以加上一个display:inline-block;
transform: scale(0.7);
css的属性，可以缩放大小

//================================================================
line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）
带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高
纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px
百分比：将计算后的值传递给后代

//================================================================
webSocket
由于 http 存在一个明显的弊端（消息只能有客户端推送到服务器端，而服务器端不能主动推送到客户端），
导致如果服务器如果有连续的变化，这时只能使用轮询，而轮询效率过低，并不适合。于是 WebSocket被发明出来
相比与 http 具有以下有点
支持双向通信，实时性更强；
可以发送文本，也可以二进制文件；
协议标识符是 ws，加密后是 wss ；
较少的控制开销。连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），
  客户端到服务端的的话，需要加上额外的4字节的掩码。而HTTP协议每次通信都需要携带完整的头部；
支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）
无跨域问题。
实现比较简单，服务端库如 socket.io、ws，可以很好的帮助我们入门。而客户端也只需要参照 api 实现即可

//================================================================
Array.slice() 与 Array.splice() 的区别？
slice
“读取”数组指定的元素，不会对原数组进行修改

  语法：arr.slice(start, end)
  start 指定选取开始位置（含）
  end 指定选取结束位置（不含）
  splice

“操作”数组指定的元素，会修改原数组，返回被删除的元素
  语法：arr.splice(index, count, [insert Elements])
  index 是操作的起始位置
  count = 0 插入元素，count > 0 删除元素
  [insert Elements] 向数组新插入的元素

//================================================================
标记清除
先所有都加上标记，再把环境中引用到的变量去除标记。剩下的就是没用的了

引用计数
跟踪记录每 个值被引用的次数。清除引用次数为0的变量 ⚠️会有循环引用问题 。循环引用如果大量存
在就会导致内存泄露。

改变自身的方法
//================================================================
基于 ES6，会改变自身值的方法一共有 9 个，分别为
pop、push、reverse、shift、sort、splice、unshift，以及两个 ES6
新增的方法 copyWithin 和 fill

不改变自身的方法
基于 ES7，不会改变自身的方法也有 9 个，分别为
concat、join、slice、toString、toLocaleString、indexOf、lastIndexOf、
未形成标准的 toSource，以及 ES7 新增的方法 includes。

数组遍历的方法

基于 ES6，不会改变自身的遍历方法一共有 12 个，分别为
forEach、every、some、filter、map、reduce、reduceRight，以及 ES6
新增的方法 entries、find、findIndex、keys、values

//===============================================================
axios特点
基于promise的异步ajax请求库
浏览器端/node端都可以使用
支持请求/响应拦截器
支持请求取消
请求/响应数据转换
批量发送多个请求

Dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，
dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。

Egg.js是阿里旗下的一个基于nodejs和koa2的企业级应用框架，基于es6，es7 和nodejs。

//================================================================
当 setState 返回一样的引用时，render会执行吗 // 会

Proxy的优势如下:

Proxy可以直接监听对象而非属性
Proxy可以直接监听数组的变化
Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的
Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改
Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利

//================================================================
原型: 对象中固有的__proto__属性，该属性指向对象的prototype原型属性。
原型链: 当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有
自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是Object.prototype所以这就是我们新建的对象为什么能够使
用toString()等方法的原因。

原生ajax
ajax是一种异步通信的方法,从服务端获取数据,达到局部刷新页面的效果。
过程：
创建XMLHttpRequest对象;
调用open方法传入三个参数 请求方式(GET/POST)、url、同步异步(true/false);
监听onreadystatechange事件，当readystate等于4时返回responseText;
调用send方法传递参数。

//================================================================
vuex 和 redux 之间的区别？
从实现原理上来说，最大的区别是两点：
Redux使用的是不可变数据，而Vuex的数据是可变的。Redux每次都是用新的state替换旧的state，而Vuex是直接修改
Redux在检测数据变化的时候，是通过diff的方式比较差异的，而Vuex其实和Vue的原理一样，是通过 getter/setter来比较的(如果看Vuex源码会知道，其实他
内部直接创建一个Vue实例用来跟踪数据变化)

`MySQL`是传统的关系型数据库，`MongoDB`则是非关系型数据库   