canvas绘图如何保存为图片
要将 Canvas 中的绘图保存为图片，可以使用 toDataURL 方法将 Canvas 转换为 base64 格式的图片数据，然后创建一个链接并设置为下载链接。下面是一个简单的示例：
// 获取 Canvas 元素
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');

// 在 Canvas 上绘制内容
ctx.fillStyle = 'green';
ctx.fillRect(10, 10, 100, 100);

// 将 Canvas 转换为 base64 格式的图片数据
const dataURL = canvas.toDataURL('image/png');

// 创建一个下载链接并设置为下载图片
const downloadLink = document.createElement('a');
downloadLink.href = dataURL;
downloadLink.download = 'canvas-image.png';
downloadLink.click();

这段代码中，首先获取了一个 Canvas 元素和它的 2D 上下文对象，然后在 Canvas 上绘制了一个绿色的矩形。接下来，使用 toDataURL 方法将 Canvas 转换为 base64 格式的图片数据。最后，创建一个 &lt;a&gt; 元素作为下载链接，并设置其 href 属性为图片数据的 URL，download 属性为下载时的文件名，最后触发点击该链接来下载图片。


上传文件时如何防御xss攻击
防御 XSS（跨站脚本攻击）是一个重要的安全问题，尤其是在处理用户上传的文件时。以下是一些防御 XSS 攻击的常见措施：

1.文件类型验证： 在接受用户上传文件之前，首先验证文件的类型和扩展名。只允许特定类型的文件上传，例如图片、文档等，并且不要相信客户端提供的文件类型信息，而是通过服务器端进行验证。
2.文件内容验证： 对于上传的文件，应该验证其内容是否符合预期。例如，对于图片文件，可以使用图像处理库（如ImageMagick或GraphicsMagick）来检查图片的尺寸、格式等属性是否合法。
3.文件名处理： 避免使用用户提供的文件名直接作为服务器上的文件名，以防止路径遍历攻击。最好使用一个随机生成的唯一文件名，并将用户提供的文件名存储在数据库中以备参考。
4.文件内容清理： 对于文本文件，可以使用过滤器或白名单机制来清理其中的恶意代码。移除或转义任何潜在的 XSS 攻击载荷，例如 &lt;script&gt; 标签和 JavaScript 事件处理器等。
5.HTTP 头部安全设置： 在服务器端配置适当的 HTTP 头部，如 Content-Security-Policy（CSP）、X-Content-Type-Options、X-Frame-Options 和 X-XSS-Protection，以帮助防御各种类型的攻击。
6.文件存储安全性： 将用户上传的文件存储在安全的位置，并确保文件系统的权限设置正确，以防止未经授权的访问和执行。
7.定期更新和监控： 定期更新和监控服务器上的安全措施，并及时修补潜在的安全漏洞。使用日志记录和监控工具来检测异常活动，并及时采取相应的应对措施。

综上所述，多层次的安全措施是防御 XSS 攻击的关键。通过综合利用这些措施，可以降低受到 XSS 攻击的风险，保护用户数据的安全。


前端 当遇到应用卡顿或内存泄漏时，你通常如何进行调试和定位
遇到前端应用卡顿或内存泄漏时，通常会采取以下调试和定位步骤：

1.使用浏览器开发者工具： 使用浏览器的开发者工具（如Chrome DevTools或Firefox Developer Tools）进行性能分析和调试。这些工具提供了各种性能分析工具，如性能监视器、内存分配分析器、CPU 使用情况分析器等，可帮助你找出应用中的性能瓶颈和内存泄漏。
2.检查内存使用情况： 使用浏览器开发者工具中的内存面板来监控应用的内存使用情况。查看哪些对象正在占用大量内存，以及是否有内存泄漏的迹象。
3.分析页面渲染性能： 使用浏览器开发者工具中的性能面板来分析页面渲染性能。检查页面加载时间、JavaScript 执行时间、布局重排次数等指标，以找出影响页面性能的问题。
4.使用性能分析工具： 使用性能分析工具（如Lighthouse、WebPageTest等）来评估网站的性能，并提供优化建议。这些工具可以帮助你找出网站加载速度慢的原因，并提供相应的优化建议。
5.排查代码问题： 仔细检查应用的代码，特别是 JavaScript 代码。查找可能导致性能问题或内存泄漏的代码，如循环引用、事件监听器未正确移除、大量数据的不必要存储等。
6.使用代码分析工具： 使用代码分析工具（如ESLint、TypeScript、Flow等）来检查代码中的潜在问题，如未使用的变量、未处理的异常、潜在的内存泄漏等。
7.采用逐步排查法： 如果无法确定问题所在，可以采用逐步排查的方法。逐步注释掉部分代码或模块，逐步重建应用，以确定问题的根本原因。
8.查看网络请求和资源加载： 检查网络请求和资源加载情况，查看是否存在网络请求阻塞或资源加载速度慢的情况，这可能会影响应用的性能。

综上所述，通过使用浏览器开发者工具、性能分析工具和代码分析工具，以及逐步排查法等方法，可以帮助你调试和定位前端应用中的卡顿和内存泄漏问题，并及时采取相应的优化措施。



怎样避免样式穿透
样式穿透是指在组件化开发中，子组件的样式被父组件的全局样式所影响，导致不希望的样式渲染。为了避免样式穿透，可以采取以下几种方法：

1.使用 CSS 模块化或作用域化： 使用 CSS 模块化或作用域化的方式，如 CSS Modules、Scoped CSS、CSS-in-JS 等，将样式限制在组件范围内。这样可以确保组件样式不受外部全局样式的影响。
2.使用 BEM（块、元素、修饰符）命名规范： 使用 BEM 命名规范可以更好地控制样式的作用范围，减少样式穿透的可能性。通过给每个组件和元素添加唯一的类名，并使用嵌套结构，可以有效地避免样式冲突。
3.使用 CSS Reset 或 Normalize： 在项目中使用 CSS Reset 或 Normalize 样式库来规范浏览器默认样式，以确保各个组件在不同浏览器中具有一致的样式表现。这样可以降低样式穿透的风险。
4.使用 CSS 变量： 使用 CSS 变量（Custom Properties）可以在组件内部定义局部变量，从而降低样式穿透的影响。通过将变量限制在组件范围内，可以减少样式冲突的可能性。
5.避免全局选择器和通配符选择器： 尽量避免在全局样式中使用通配符选择器（如 *）和全局选择器（如 body、html）。这些选择器会影响到整个页面的样式，增加了样式穿透的风险。
6.使用 CSS-in-JS： 使用 CSS-in-JS 方案可以将组件的样式封装在 JavaScript 中，从而实现更好的样式作用域控制。一些 CSS-in-JS 库提供了自动化的样式隔离功能，可以有效地避免样式穿透问题。
7.使用 Shadow DOM： 如果项目支持，可以考虑使用 Shadow DOM 技术来实现组件样式的封装和隔离。Shadow DOM 可以创建一个独立的 DOM 子树，使组件样式不受外部样式的影响。

综上所述，通过使用 CSS 模块化或作用域化、遵循命名规范、规范化浏览器默认样式、使用 CSS 变量等方法，可以有效地避免样式穿透问题，并提高组件化开发的效率和可维护性。



大文件上传前端怎么处理，具体怎么实现，如何实现进度条
在前端处理大文件上传时，通常会遇到以下挑战：如何有效地上传大文件，并显示上传进度。以下是一种常见的实现方法：

1.分片上传： 将大文件分成多个小块（通常是固定大小的块），然后将这些小块逐个上传到服务器。这样可以避免一次性上传整个大文件，减少网络传输的负担，并允许在上传过程中显示进度。
2.选择文件： 使用 &lt;input type="file"&gt; 标签或者一些上传组件，让用户选择要上传的文件。
3.切片文件： 使用 JavaScript 将大文件切割成多个小块。可以使用 File.slice() 方法来实现文件的切片，将切片后的文件存储在数组中以备上传。
4.逐个上传切片： 使用 AJAX 或者其他 HTTP 请求方式，逐个上传切片到服务器。可以在每次上传成功后，继续上传下一个切片，直到所有切片上传完成。
5.显示进度条： 在上传过程中，通过监听上传事件，并根据已上传的文件大小和总文件大小计算出上传进度，并将其显示在页面上的进度条中。可以使用 HTML5 的 &lt;progress&gt; 元素或者自定义样式的 &lt;div&gt; 元素来实现进度条的显示。
6.服务器端接收和合并文件： 服务器端接收到上传的文件切片后，将其存储在临时目录中，并在所有切片上传完成后，将这些切片合并成完整的文件。可以使用服务器端脚本（如Node.js、PHP等）来实现文件切片的接收和合并。
7.处理上传中断和错误： 在上传过程中，可能会遇到网络中断、服务器错误等情况。因此，需要在前端和后端实现相应的错误处理机制，以确保上传过程的可靠性和稳定性。

综上所述，通过分片上传、实时显示上传进度、服务器端的切片接收和合并等步骤，可以有效地处理大文件上传，并实现进度条的显示。



说一说插槽的分类和作用
slot插槽，一般是我们在封装组件的时候使用！当我们不知道组件内的内容不知道以哪种形式来展示内容的时候，可以用slot来占据一个位置，最后可以通过父组件以内容的形式传递过来，展示相应的内容，主要分为三种：

默认插槽：又叫匿名插槽，当slot没有指定一个相应的name属性值的时候，显示一个默认的插槽，一个组件内只能有一个默认插槽。
具名插槽：顾名思义，就是带有一个具体名字的插槽，也就是带有name属性的slot插槽，在一个组件内是允许出现多个具名插槽的。
作用域插槽：默认插槽、具名插槽一个结合体，可以是匿名插槽，也可以是具名插槽。这个不同之处在于子组件渲染作用域插槽的时候可以将子组件内部的数据传递给父组件，让父组件根据子组件传过来的数据决定要展示的具体内容，该如何渲染该插槽。

实现原理：当子组件的vm实例化的时，获取到父组件传入的slot标签的内容，存放在vm.$slot中，默认插槽为vm.$slot.default,具名插槽为vm.$slot.具体名字，当组件执行渲染函数时，遇到slot标签，使用$slot中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可以称该插槽为作用域插槽。

作者：Aidan路修远i
链接：https://juejin.cn/post/7345105799864533033
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



面试常问：为什么 Vite 速度比 Webpack 快？
https://juejin.cn/post/7344916114204049445?utm_source=gold_browser_extension

webpack打包过程
1.识别入口文件
2.通过逐层识别模块依赖。（Commonjs、amd或者es6的import，webpack都会对其进行分析。来获取代码的依赖）
3.webpack做的就是分析代码。转换代码，编译代码，输出代码
4.最终形成打包后的代码

链接：https://juejin.cn/post/7039224502655402021


微信小程序分包原理，的好处
微信小程序分包是一种优化手段，旨在解决小程序体积过大导致加载时间过长的问题。其原理是将小程序的代码及资源按照一定的规则划分成多个包，
使得在用户首次打开小程序时，只需加载必要的主包，而在需要时再动态加载其他分包，从而减少了首次加载所需的时间和网络流量，提升了用户体验。

好处包括：
1. **加快启动速度：** 小程序分包可以让主包的体积变小，减少了首次加载需要的时间，因此可以加快小程序的启动速度，让用户更快地进入小程序。
2. **降低流量消耗：** 将小程序的功能按需划分成多个分包，可以减少首次加载时所需的网络流量，特别是对于一些功能较为复杂或者大量资源的小程序，
  这一优势尤为明显。
3. **优化用户体验：** 加快启动速度和减少流量消耗都可以提升用户体验，让用户更加愿意使用小程序，增加用户黏性和满意度。
4. **提高开发效率：** 小程序分包可以让开发者更加灵活地组织代码和资源，更好地进行模块化开发和维护，降低了开发的复杂度和难度。
总的来说，微信小程序分包通过优化加载速度、降低流量消耗等方面，可以提升小程序的整体性能和用户体验，是一种非常有效的优化手段。



https://juejin.cn/post/7353110675914489894?utm_source=gold_browser_extension
这里列举的是被问到最多的一些问题
下面就是一些技术相关的面试题了
在过去的项目中，你是如何处理代码分割与懒加载的？请结合具体实例说明。
在你之前的项目中，你是如何应对内存泄漏问题的？
在一个复杂的SPA项目中，你是如何管理和优化状态管理的？
Webpack的工作原理和优化策略
在不使用Webpack的情况下，可以采用以下方法来优化前端性能
请简要解释React Hooks中的useMemo和useCallback，以及它们如何帮助优化性能？
当使用useState Hook时，有哪些常见的性能优化策略？
请描述React的“Concurrent Mode”（并发模式）以及它如何影响性能优化？
请简述Vue 3中的新特性及其对性能的影响？
Vue 3中的Composition API是什么，以及它在项目开发中如何提高代码质量与可维护性？
Vue 3如何实现服务端渲染（SSR）？请简述其工作原理及优势。
Vue 3中的自定义指令有哪些改进？请举例说明如何创建一个自定义指令。


React18中引入的并发模式是什么，它带来了哪些改进
React 18 引入的并发模式是指 React 中的并发模式，旨在提高应用程序的性能和响应能力。在 React 18 中，引入了 Suspense 和 Concurrent Mode 来实现并发渲染。这个新的渲染模式允许 React 在等待某些资源（例如数据加载、代码分割或懒加载组件）时，继续渲染用户界面的其余部分，而不会阻塞用户界面。
Concurrent Mode 带来了以下几点改进：

1.更好的用户体验：通过允许 React 在加载资源时继续渲染 UI，可以减少页面加载时间，提高用户体验。用户可以看到更快的反馈和更新。
2.更好的性能：并发模式允许 React 在多个优先级任务之间切换，从而更有效地利用浏览器的资源，并在更短的时间内完成渲染。
3.更低的 CPU 使用：通过利用空闲时间进行渲染，React 可以更智能地管理渲染任务，减少了对 CPU 的压力，提高了页面的响应能力。
4.更容易的代码分割和懒加载：并发模式简化了代码分割和懒加载的实现。开发人员可以更轻松地将应用程序分解为更小的代码块，并在需要时延迟加载它们，而不会影响用户体验。
5.更好的错误处理：Suspense 的引入使得在等待异步操作完成时能够更容易地处理加载过程中可能出现的错误，从而提高了应用程序的可靠性和稳定性。

总的来说，React 18 中的并发模式带来了更好的性能、用户体验和开发体验，使得开发人员能够构建更快速、更具响应性的 Web 应用程序。

React最新面试攻略
https://juejin.cn/post/7350602398619074610


如何使用CSS实现硬件加速？
硬件加速是指通过创建独立的复合图层，让GPU来渲染这个图层，从而提高性能， 一般触发硬件加速的CSS属性有transform、opacity、filter，为了避免2D动画在 开始和结束的时候的repaint操作，一般使用tranform:translateZ(0)


11. vite比webpack快在哪里
https://juejin.cn/post/7350535815132659749

12. 说一下你对Monorepo的理解
Monorepo 是一种项目代码管理方式，指单个仓库中管理多个项目，有助于简化代码共享、版本控制、构建和部署等方面的复杂性，并提供更好的可重用性和协作性。Monorepo 提倡了开放、透明、共享的组织文化，这种方法已经被很多大型公司广泛使用，如 Google、Facebook 和 Microsoft 等。

链接：https://juejin.cn/post/7350535815132659749


14.为什么pnpm比npm快
Pnpm 比 npm 快的原因在于其优化的文件存储方式、依赖管理方式以及并行下载能力。 以下是详细介绍：

Pnpm 使用基于内容寻址的文件系统来存储磁盘上的所有文件，这意味着它不会在磁盘中重复存储相同的依赖包，即使这些依赖包被不同的项目所依赖。这种存储方式使得Pnpm在安装依赖时能够更高效地利用磁盘空间，同时也减少了下载和安装的时间。
Pnpm 在下载和安装依赖时采用了并行下载的能力，这进一步提高了安装速度。
Pnpm 还具有一些其他特性，例如节省空间的硬链接和符号链接的使用，这些都有助于提高其性能。
链接：https://juejin.cn/post/7350535815132659749
